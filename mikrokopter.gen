/*/
 * Copyright (c) 2015-2016 LAAS/CNRS
 * All rights reserved.
 *
 * Redistribution and use  in source  and binary  forms,  with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *   1. Redistributions of  source  code must retain the  above copyright
 *      notice and this list of conditions.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice and  this list of  conditions in the  documentation and/or
 *      other materials provided with the distribution.
 *
 *					Anthony Mallet on Fri Feb 13 2015
 */
#pragma require "openrobots-idl >= 1.1"

#include "or/pose/pose_estimator.gen"
#include "or/robot/rotorcraft.gen"

component mikrokopter {
  version		"1.1";
  email			"openrobots@laas.fr";
  lang			"c";
  require		"genom3 >= 2.99.26";
  codels-require	"eigen3";

  provides	or_rotorcraft;
  uses		or_pose_estimator;

  const unsigned short max_rotors = 8;

  exception e_sys { short code; string<128> what; };
  exception e_baddev { string<256> dev; };
  exception e_rotor_failure { unsigned short id; };
  exception e_rotor_not_disabled { unsigned short id; };
  exception e_started, e_connection, e_range, e_input;

  native conn_s;
  native log_s;

  struct rotor_s {
    boolean emerg, spinning, starting;
    double pwm;
    double velocity, target;
    double current;
  };
  typedef sequence<rotor_s, max_rotors> rotors_s;

  port out	rotors_s rotors;
  port out	or_pose_estimator::state imu;


  /* --- internal state ---------------------------------------------------- */

  ids {
    /* serial connection */
    conn_s conn;

    /* data timestamps and transmission rate */
    struct sensor_time_s {
      struct ts_s {
        octet seq;
        double ts, offset;
      } imu, motor[max_rotors], battery;

      struct rate_s {
        double imu, motor, battery;
      } rate;
    } sensor_time;

    /* battery data */
    struct battery_s {
      double alarm;
      double level;
    } battery;

    /* imu calibration */
    struct imu_calibration_s {
      double gscale[9], gbias[3], gstddev[3];
      double ascale[9], abias[3], astddev[3];
    } imu_calibration;
    boolean imu_calibration_updated;

    /* rotors state */
    sequence<boolean, max_rotors> disabled_motors;

    /* servo parameters */
    struct servo_s {
      double vmin, vmax;
      or_rotorcraft::ts_wrench wrench;
    } servo;

    /* logging */
    log_s log;
  };

  attribute get_sensor_rate(out sensor_time.rate);
  attribute set_sensor_rate(in sensor_time.rate) {
    validate mk_set_sensor_rate(local in rate, in conn, out sensor_time);
  };

  attribute get_battery(out battery);
  attribute set_battery_alarm(in battery.alarm);

  attribute get_imu_calibration(out imu_calibration);
  attribute set_imu_calibration(in imu_calibration) {
    validate mk_set_imu_calibration(out imu_calibration_updated);
  };


  attribute get_disabled_motors(out disabled_motors);

  attribute set_vlimit(in servo.vmin, in servo.vmax);


  /* --- tasks ------------------------------------------------------------- */

  const unsigned short control_period_ms = 1;

  task main {
    period control_period_ms ms;

    codel<start> mk_main_init(out ::ids, in rotors, in imu)
      yield main;
    codel<main> mk_main_perm(in conn, in battery, in imu_calibration,
                             inout imu_calibration_updated,
                             out rotors, out imu)
      yield pause::main;

    codel<stop> mk_main_stop(inout log)
      yield ether;
  };

  task comm {
    codel<start> mk_comm_start(out conn)
      yield poll;

    async codel<poll> mk_comm_poll(in conn)
      yield nodata, recv;
    codel<nodata> mk_comm_nodata(inout conn, inout sensor_time,
                                 out imu, out rotors, out battery)
      yield poll;
    codel<recv> mk_comm_recv(inout conn, in log, in imu_calibration,
                             inout sensor_time,
                             out imu, out rotors, out battery)
      yield poll;

    codel<stop> mk_comm_stop(inout conn)
      yield ether;

    throw e_sys;
  };


  /* --- hw connection ----------------------------------------------------- */

  activity connect(
    in string<64> serial[2] = {
      "/dev/ttyUSB0" :"Main serial device",
      "" :"Optional second serial device"
    } :"Serial devices",
    in unsigned long baud = 115200 :"Baud rate") {

    doc		"Connect to the hardware";
    task	comm;

    codel<start> mk_connect_start(in serial, in baud, inout conn,
                                  inout sensor_time)
      yield ether;

    throw e_sys, e_baddev;
    interrupt servo;
  };

  activity disconnect() {
    doc		"Disconnect from the hardware";
    task	comm;

    codel<start> mk_disconnect_start(inout conn)
      yield ether;
  };

  activity monitor() {
    doc		"Monitor connection status";
    task	comm;

    codel<start, sleep> mk_monitor_check(in conn) yield pause::sleep, ether;
  };

  function disable_motor(in unsigned short motor) {
    doc		"Disable checking a motor status when it is disconnected";
    codel mk_disable_motor(in motor, out disabled_motors);
  };

  function enable_motor(in unsigned short motor) {
    doc		"Disable checking a motor status when it is disconnected";
    codel mk_enable_motor(in motor, out disabled_motors);
  };


  /* --- calibration ------------------------------------------------------- */

  activity calibrate_imu(in double tstill, in unsigned short nposes) {
    doc		"Calibrate imu";
    task	main;

    codel<start> mk_calibrate_imu_start(in tstill, in nposes)
      yield collect;
    codel<collect> mk_calibrate_imu_collect(in imu)
      yield pause::collect, main;
    codel<main> mk_calibrate_imu_main(out imu_calibration,
                                      out imu_calibration_updated)
      yield ether;

    throw e_sys, e_connection;

    interrupt calibrate_imu, set_zero;
  };

  activity set_zero() {
    doc		"Set imu attitude to zero";
    task	main;

    local double accum[3], gycum[3];
    local unsigned long n;

    codel<start> mk_set_zero_start(out accum, out gycum, out n)
      yield collect;
    codel<collect> mk_set_zero_collect(in imu, inout accum, inout gycum,
                                       inout n)
      yield pause::collect, main;
    codel<main> mk_set_zero(inout accum, inout gycum,
                            out imu_calibration, out imu_calibration_updated)
      yield ether;

    throw e_sys;

    interrupt calibrate_imu, set_zero;
  };


  /* --- flight ------------------------------------------------------------ */

  activity start() {
    doc		"Spin propellers at the lowest velocity";
    task	main;

    local unsigned short state;

    codel<start> mk_start_start(in conn, out state, in rotors,
                                in disabled_motors)
      yield monitor;
    codel<monitor> mk_start_monitor(in conn, inout state, in rotors,
                                    in disabled_motors)
      yield pause::monitor, ether;
    codel<stop> mk_start_stop(in conn)
      yield ether;

    interrupt start;
    throw e_connection, e_started, e_rotor_failure, e_rotor_not_disabled;
  };

  activity servo() {
    doc		"Control the propellers according to the given wrench";
    task	main;

    codel<start> mk_servo_start(in conn, out servo.wrench, in cmd_wrench)
      yield main;

    codel<main> mk_servo_main(in conn, inout servo,
                              in rotors, in disabled_motors)
      yield pause::start;

    codel<stop> mk_servo_stop(in conn, out servo,
                              in rotors)
      yield ether;

    throw e_connection, e_rotor_failure, e_input;
  };

  function set_wrench(in or::rb3d::wrench wrench = {
      .f =: "Force", .t =: "Torque"
    }) {
    doc		"Set the given wrench once";

    codel mk_set_wrench(in wrench, out servo.wrench::target);
  };

  function stop() {
    doc		"Stop all propellers";
    interrupt servo, start;
    codel mk_stop(in conn);
  };


  /* --- logging ----------------------------------------------------------- */

  function log(in string<64> path = "/tmp/mikrokopter.log": "Log file name") {
    doc		"Log IMU and commanded wrench";

    codel mk_log_start(in path, inout log);

    throw e_sys;
  };

  function log_stop() {
    doc		"Stop logging";

    codel mk_log_stop(out log);
  };
};
