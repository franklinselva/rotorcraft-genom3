/*/
 * Copyright (c) 2015-2017 LAAS/CNRS
 * All rights reserved.
 *
 * Redistribution and use  in source  and binary  forms,  with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *   1. Redistributions of  source  code must retain the  above copyright
 *      notice and this list of conditions.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice and  this list of  conditions in the  documentation and/or
 *      other materials provided with the distribution.
 *
 *					Anthony Mallet on Fri Feb 13 2015
 */
#pragma require "openrobots-idl >= 1.4"

#include "or/pose/pose_estimator.gen"
#include "or/robot/rotorcraft.gen"

component mikrokopter {
  version		"1.6.1";
  email			"openrobots@laas.fr";
  lang			"c";
  require		"genom3 >= 2.99.26";
  codels-require	"eigen3";

  provides	or_rotorcraft;
  uses		or_pose_estimator;

  exception e_sys { short code; string<128> what; };
  exception e_baddev { string<256> dev; };
  exception e_rotor_failure { unsigned short id; };
  exception e_rotor_not_disabled { unsigned short id; };
  exception e_started, e_connection, e_range, e_input;

  native conn_s;
  native log_s;

  port out	or_pose_estimator::state imu;


  /* --- internal state ---------------------------------------------------- */

  ids {
    /* serial connection */
    conn_s conn;

    /* data timestamps and transmission rate */
    struct sensor_time_s {
      struct ts_s {
        octet seq;
        double ts, offset;
      } imu, motor[or_rotorcraft::max_rotors], battery;

      struct rate_s {
        double imu, motor, battery;
      } rate;
    } sensor_time;

    /* battery data */
    struct battery_s {
      double min, max;
      double level;
    } battery;

    /* imu calibration & filtering */
    struct imu_calibration_s {
      double gscale[9], gbias[3], gstddev[3];
      double ascale[9], abias[3], astddev[3];
    } imu_calibration;
    boolean imu_calibration_updated;

    struct imu_filter_s {
      boolean enable;
      double gain, Q;
    } imu_filter;

    /* rotors state */
    or_rotorcraft::rotor_state rotor_state[or_rotorcraft::max_rotors];
    double rotor_wd[or_rotorcraft::max_rotors];

    /* servo parameters */
    struct servo_s {
      double ramp;
    } servo;

    /* logging */
    log_s log;
  };

  attribute get_sensor_rate(out sensor_time.rate);
  attribute set_sensor_rate(in sensor_time.rate) {
    validate mk_set_sensor_rate(local in rate, in conn, out sensor_time);
  };

  attribute get_battery(out battery);
  attribute set_battery_limits(in battery.min, in battery.max) {
    validate mk_set_battery_limits(in min, in max);

    throw e_range;
  };

  attribute get_imu_calibration(out imu_calibration);
  attribute set_imu_calibration(in imu_calibration) {
    validate mk_set_imu_calibration(out imu_calibration_updated);
  };

  attribute get_imu_filter(out imu_filter);
  attribute set_imu_filter(in imu_filter) {
    validate mk_set_imu_filter(local in imu_filter);
  };

  attribute set_ramp(in servo.ramp);


  /* --- tasks ------------------------------------------------------------- */

  const unsigned short control_period_ms = 1;

  task main {
    period control_period_ms ms;

    codel<start> mk_main_init(out ::ids, in imu)
      yield main;
    codel<main> mk_main_perm(in conn, in battery, in imu_calibration,
                             in imu_filter, in rotor_state, in rotor_wd,
                             inout imu_calibration_updated,
                             in log, out rotor_measure, out imu)
      yield pause::main;

    codel<stop> mk_main_stop(inout log)
      yield ether;
  };

  task comm {
    codel<start> mk_comm_start(out conn)
      yield poll;

    async codel<poll> mk_comm_poll(in conn)
      yield nodata, recv;
    codel<nodata> mk_comm_nodata(inout conn, inout sensor_time,
                                 out imu, out battery)
      yield poll;
    codel<recv> mk_comm_recv(inout conn, in imu_calibration, inout sensor_time,
                             out imu, out rotor_state, out battery)
      yield poll, recv;

    codel<stop> mk_comm_stop(inout conn)
      yield ether;

    throw e_sys;
  };


  /* --- hw connection ----------------------------------------------------- */

  activity connect(
    in string<64> serial[2] = {
      "/dev/ttyUSB0" :"Main serial device",
      "" :"Optional second serial device"
    } :"Serial devices",
    in unsigned long baud = 115200 :"Baud rate") {

    doc		"Connect to the hardware";
    task	comm;

    codel<start> mk_connect_start(in serial, in baud, inout conn,
                                  inout sensor_time)
      yield ether;

    throw e_sys, e_baddev;
    interrupt servo;
  };

  activity disconnect() {
    doc		"Disconnect from the hardware";
    task	comm;

    codel<start> mk_disconnect_start(inout conn)
      yield ether;
  };

  activity monitor() {
    doc		"Monitor connection status";
    task	comm;

    codel<start, sleep> mk_monitor_check(in conn) yield pause::sleep, ether;
  };

  function disable_motor(in unsigned short motor) {
    doc		"Disable checking a motor status when it is disconnected";

    codel mk_disable_motor(in motor, in conn, out rotor_state);
  };

  function enable_motor(in unsigned short motor) {
    doc		"Disable checking a motor status when it is disconnected";

    codel mk_enable_motor(in motor, in conn, out rotor_state);
  };


  /* --- calibration ------------------------------------------------------- */

  activity calibrate_imu(in double tstill, in unsigned short nposes) {
    doc		"Calibrate imu";
    task	main;

    codel<start> mk_calibrate_imu_start(in tstill, in nposes)
      yield collect;
    codel<collect> mk_calibrate_imu_collect(in imu)
      yield pause::collect, main;
    codel<main> mk_calibrate_imu_main(out imu_calibration,
                                      out imu_calibration_updated)
      yield ether;

    throw e_sys, e_connection;

    interrupt calibrate_imu, set_zero;
  };

  activity set_zero() {
    doc		"Set imu attitude to zero";
    task	main;

    local double accum[3], gycum[3];
    local unsigned long n;

    codel<start> mk_set_zero_start(out accum, out gycum, out n)
      yield collect;
    codel<collect> mk_set_zero_collect(in imu, inout accum, inout gycum,
                                       inout n)
      yield pause::collect, main;
    codel<main> mk_set_zero(inout accum, inout gycum,
                            out imu_calibration, out imu_calibration_updated)
      yield ether;

    throw e_sys;

    interrupt calibrate_imu, set_zero;
  };


  /* --- flight ------------------------------------------------------------ */

  activity start() {
    doc		"Spin propellers at the lowest velocity";
    task	main;

    local unsigned short state;

    codel<start> mk_start_start(in conn, out state, in rotor_state)
      yield monitor;
    codel<monitor> mk_start_monitor(in conn, inout state, in rotor_state)
      yield pause::monitor, ether;
    codel<stop> mk_start_stop(in conn, in rotor_state)
      yield pause::stop, ether;

    interrupt start;
    throw e_connection, e_started, e_rotor_failure, e_rotor_not_disabled;
  };

  activity servo() {
    doc		"Control the propellers according to the given velocities";
    task	main;

    local double scale;

    codel<start> mk_servo_start(out scale)
      yield main;
    codel<main> mk_servo_main(in conn, in rotor_state, out rotor_wd,
                              in rotor_input, in servo, inout scale)
      yield pause::main, stop;

    codel<stop> mk_servo_stop(in conn)
      yield ether;

    throw e_connection, e_rotor_failure, e_input;
  };

  function set_velocity(
       in or_rotorcraft::rotor_control desired =: "Propeller velocities") {
    doc		"Set the given propeller velocity, once";

    validate mk_validate_input(in rotor_state, inout desired);
    codel mk_set_velocity(in conn, in rotor_state, out rotor_wd, in desired);

    interrupt servo;
    throw e_connection, e_rotor_failure;
  };

  function set_throttle(
       in or_rotorcraft::rotor_control desired =: "Propeller throttles") {
    doc		"Set the given propeller voltage";

    validate mk_validate_input(in rotor_state, inout desired);
    codel mk_set_throttle(in conn, in rotor_state, out rotor_wd, in desired);

    interrupt servo;
    throw e_connection, e_rotor_failure;
  };

  activity stop() {
    doc		"Stop all propellers";
    task	main;

    codel<start> mk_stop(in conn, in rotor_state)
      yield pause::start, ether;

    interrupt servo, start;
  };


  /* --- logging ----------------------------------------------------------- */

  function log(in string<64> path = "/tmp/mikrokopter.log": "Log file name") {
    doc		"Log IMU and commanded wrench";

    codel mk_log_start(in path, inout log);

    throw e_sys;
  };

  function log_stop() {
    doc		"Stop logging";

    codel mk_log_stop(out log);
  };
};
